#!/usr/bin/env python3

# Python script that monitors the battery status and sends notifications when the
# battery's capacity reaches a critical level.
# It reads the battery status and capacity from system files and then prints a pretty-formatted
# status message for the battery.
# It's for use in minimalist windows managers bars (e.g. dwm, qtile).

import os
import subprocess
from enum import Enum, auto


class BatStatus(Enum):
    Charging = auto()
    Discharging = auto()
    Full = auto()
    Unknown = auto()


IconsMap = list[tuple[int, int, str]]
ICONS_DISCHARGING: IconsMap = [
    (1, 10, ''),
    (11, 20, ''),
    (21, 30, ''),
    (31, 40, ''),
    (41, 50, ''),
    (51, 60, ''),
    (61, 70, ''),
    (71, 80, ''),
    (81, 90, ''),
    (91, 94, ''),
    (95, 100, ''),
]
ICONS_CHARGING: IconsMap = [
    (1, 14, ''),
    (15, 29, ''),
    (30, 44, ''),
    (45, 59, ''),
    (60, 74, ''),
    (75, 89, ''),
    (90, 100, ''),
]
ICONS_UNKNOWN: IconsMap = [(1, 100, '')]
ICONS_FULL: IconsMap = [(1, 100, '')]
ICONS_MAPS: dict[BatStatus, IconsMap] = {
    BatStatus.Charging: ICONS_CHARGING,
    BatStatus.Discharging: ICONS_DISCHARGING,
    BatStatus.Full: ICONS_FULL,
}


class Icons:
    @staticmethod
    def get_icon_map(status: BatStatus) -> IconsMap:
        return ICONS_MAPS.get(status, ICONS_UNKNOWN)

    @staticmethod
    def get_icon_for_capacity(status: BatStatus, capacity: int) -> str:
        for range_start, range_end, icon in Icons.get_icon_map(status):
            if range_start <= capacity <= range_end:
                return icon
        return ICONS_UNKNOWN[0][2]


class System:
    battery_name: str = os.environ.get('BATTERY', 'BAT0')
    battery_crit_cap_icon: str = 'battery-level-10-symbolic'
    power_supply_status: str = f'/sys/class/power_supply/{battery_name}/status'
    power_supply_capacity: str = f'/sys/class/power_supply/{battery_name}/capacity'

    @staticmethod
    def run(args: list[str]) -> int:
        try:
            completed_process = subprocess.run(
                args,  # noqa: S603
                stdout=subprocess.PIPE,
                stdin=subprocess.PIPE,
                text=True,
                check=True,
            )
            return completed_process.returncode
        except subprocess.SubprocessError as e:
            raise e

    @staticmethod
    def send_notification(
        title: str,
        body: str,
        icon: str,
        bin: str,
        urgency: str = 'normal',
    ) -> None:
        args = [
            bin,
            '--app-name=Battery',
            f'--icon={icon}',
            f'--urgency={urgency}',
            title,
            body,
        ]
        System.run(args)
